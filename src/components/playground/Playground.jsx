"use client";

import React, { useState, useEffect, useCallback } from "react";
import Image from "next/image";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import TwoPanelSidebar from "./TwoPanelSidebar";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Share2,
  History,
  BookOpen,
  Check,
  Copy,
  PanelLeftOpen,
  PanelLeftClose,
  Zap,
  FolderOpen,
  Settings,
  Globe,
  Search,
  Plus,
  X,
  Moon,
  Sun,
  ChevronLeft,
  ChevronRight,
  ChevronDown,
  Pencil,
  Send,
  Trash2,
  Loader2,
  MoreHorizontal,
  FileText,
  Edit,
  GripVertical,
  GripHorizontal,
  Upload,
  Download,
  FileUp,
  FileDown,
  Columns,
  SplitSquareHorizontal,
} from "lucide-react";
import { useTheme } from "@/contexts/ThemeContext";
import { useAuth } from "@/contexts/AuthContext";
import { useCollections } from "@/contexts/CollectionsContext";
import { getThemeClasses, getMethodColors } from "@/lib/theme";
import RequestPanel from "./RequestPanel";
import ResponsePanel from "./ResponsePanel";
import { generateShareableUrl, getSharedRequest } from "@/lib/share-encoding";
import { saveToHistory } from "@/lib/storage";
import {
  processRequestWithVariables,
  getEnvironments,
  getActiveEnvironment,
  setActiveEnvironment,
  createEnvironment,
  updateEnvironment,
  deleteEnvironment,
  getActiveVariables,
  addVariableToEnvironment,
  updateVariableInEnvironment,
  deleteVariableFromEnvironment,
} from "@/lib/environments";
import { generateRequestName, isAutoGeneratedName } from "@/lib/request-utils";
import DocGeneratorModal from "@/components/docs/DocGeneratorModal";
import SearchInput from "@/components/ui/SearchInput";

function UserAvatar({ user, isDark }) {
  const [imageLoaded, setImageLoaded] = useState(true);
  const [imageSrc, setImageSrc] = useState(null);

  useEffect(() => {
    if (user?.user_metadata?.avatar_url) {
      // Fix Google profile image URL by removing size parameter and adding referrer policy bypass
      let avatarUrl = user.user_metadata.avatar_url;

      // If it's a Google profile image, modify the URL for better compatibility
      if (avatarUrl.includes("googleusercontent.com")) {
        // Remove the size parameter (=s96-c) and replace with a larger size
        avatarUrl = avatarUrl.replace(/=s\d+-c$/, "=s128-c");
      }

      setImageSrc(avatarUrl);
      setImageLoaded(true);
    }
  }, [user]);

  const getInitials = () => {
    if (user?.user_metadata?.full_name) {
      return user.user_metadata.full_name.charAt(0).toUpperCase();
    }
    if (user?.user_metadata?.name) {
      return user.user_metadata.name.charAt(0).toUpperCase();
    }
    if (user?.email) {
      return user.email.charAt(0).toUpperCase();
    }
    return "U";
  };

  if (imageLoaded && imageSrc) {
    return (
      <div className="w-8 h-8 rounded-full overflow-hidden cursor-pointer">
        <Image
          src={imageSrc}
          alt="User avatar"
          width={32}
          height={32}
          className="object-cover"
          unoptimized
          onError={() => {
            console.log("Profile image failed to load:", imageSrc);
            setImageLoaded(false);
          }}
        />
      </div>
    );
  }

  return (
    <div
      className="h-8 w-8 rounded-full flex items-center justify-center cursor-pointer text-white font-medium text-sm"
      style={{
        backgroundColor: "#171717",
      }}
    >
      {getInitials()}
    </div>
  );
}

export default function Playground() {
  const { toggleTheme, isDark } = useTheme();
  const { user, signOut, loading: authLoading } = useAuth();
  const {
    collections,
    activeCollectionId,
    setActiveCollectionId,
    addRequestToCollection,
    updateRequestInCollection,
    saveToHistory,
    createCollection,
    deleteCollection,
    getCollectionsWithDocs,
  } = useCollections();
  const themeClasses = getThemeClasses(isDark);
  // Request tabs state - will be restored from localStorage if available
  const [requestTabs, setRequestTabs] = useState([]);
  const [activeTabId, setActiveTabId] = useState(null);
  const [tabsInitialized, setTabsInitialized] = useState(false);

  const [shareUrl, setShareUrl] = useState("");
  const [showShared, setShowShared] = useState(false);
  const [shareDialogOpen, setShareDialogOpen] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(
    typeof window !== "undefined" && window.innerWidth < 1024
  );
  const [activeMenuTab, setActiveMenuTab] = useState("collections");
  const [sidebarContentOpen, setSidebarContentOpen] = useState(true); // Track if sidebar content is visible
  const [sidebarContentWidth, setSidebarContentWidth] = useState(200); // Width of the content panel in pixels
  const [isSidebarResizing, setIsSidebarResizing] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [searchModalOpen, setSearchModalOpen] = useState(false);

  // Handle search modal keyboard shortcuts and clicks
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === "Escape" && searchModalOpen) {
        setSearchModalOpen(false);
        setSearchQuery("");
      }
    };

    const handleClickOutside = (e) => {
      if (searchModalOpen && !e.target.closest(".search-container")) {
        setSearchModalOpen(false);
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("mousedown", handleClickOutside);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [searchModalOpen]);
  const [editingRequestName, setEditingRequestName] = useState(false);
  const [layoutMode, setLayoutMode] = useState("single"); // 'single' or 'split'
  const [requestPanelWidth, setRequestPanelWidth] = useState(50); // percentage
  const [requestPanelHeight, setRequestPanelHeight] = useState(35); // percentage for single column
  const [isDragging, setIsDragging] = useState(false);
  const [showImportExportModal, setShowImportExportModal] = useState(false);
  const [importData, setImportData] = useState("");
  const [importError, setImportError] = useState("");

  // Drag handling functions for resizable panels (must be at top level)
  const handleMouseDown = (e) => {
    setIsDragging(true);
    e.preventDefault();
  };

  const handleMouseMove = useCallback(
    (e) => {
      if (isDragging) {
        const container = document.querySelector("[data-layout-container]");
        if (container) {
          const containerRect = container.getBoundingClientRect();

          if (layoutMode === "split") {
            // Horizontal dragging for split layout
            const newWidth =
              ((e.clientX - containerRect.left) / containerRect.width) * 100;
            setRequestPanelWidth(Math.min(Math.max(newWidth, 20), 80)); // Limit between 20% and 80%
          } else {
            // Vertical dragging for single column layout
            const newHeight =
              ((e.clientY - containerRect.top) / containerRect.height) * 100;
            setRequestPanelHeight(Math.min(Math.max(newHeight, 20), 80)); // Limit between 20% and 80%
          }
        }
      }
    },
    [isDragging, layoutMode]
  );

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // Sidebar resize handlers
  const handleSidebarResizeStart = (e) => {
    setIsSidebarResizing(true);
    e.preventDefault();
    e.stopPropagation();
  };

  const handleSidebarResizeMove = useCallback(
    (e) => {
      if (isSidebarResizing) {
        const sidebar = document.querySelector("[data-sidebar-container]");
        if (sidebar) {
          const sidebarRect = sidebar.getBoundingClientRect();
          // Calculate new width: mouse position - sidebar left - navigation panel width (56px)
          const newWidth = e.clientX - sidebarRect.left - 56;
          // Apply constraints: min 150px, max 400px
          const constrainedWidth = Math.min(Math.max(newWidth, 150), 400);
          setSidebarContentWidth(constrainedWidth);
        }
      }
    },
    [isSidebarResizing]
  );

  const handleSidebarResizeEnd = () => {
    setIsSidebarResizing(false);
  };

  // Handle navigation item clicks with toggle behavior
  const handleNavItemClick = (itemId) => {
    if (activeMenuTab === itemId && sidebarContentOpen) {
      // If clicking the same active tab and content is open, close it
      setSidebarContentOpen(false);
    } else {
      // If clicking a different tab or content is closed, open/switch to it
      setActiveMenuTab(itemId);
      setSidebarContentOpen(true);
    }
  };

  // Effect to handle mouse events (must be at top level)
  useEffect(() => {
    if (isDragging) {
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isDragging, handleMouseMove]);

  // Effect to handle sidebar resize events
  useEffect(() => {
    if (isSidebarResizing) {
      document.addEventListener("mousemove", handleSidebarResizeMove);
      document.addEventListener("mouseup", handleSidebarResizeEnd);
      return () => {
        document.removeEventListener("mousemove", handleSidebarResizeMove);
        document.removeEventListener("mouseup", handleSidebarResizeEnd);
      };
    }
  }, [isSidebarResizing, handleSidebarResizeMove]);

  // Collections state
  const [expandedCollections, setExpandedCollections] = useState(
    new Set(["my-api-tests"])
  ); // Default expanded
  const [editingCollection, setEditingCollection] = useState(null);
  const [editingRequest, setEditingRequest] = useState(null);

  // Modal states
  const [docsModalOpen, setDocsModalOpen] = useState(false);
  const [selectedCollectionForDocs, setSelectedCollectionForDocs] =
    useState(null);
  const [settingsModalOpen, setSettingsModalOpen] = useState(false);
  const [createCollectionDialogOpen, setCreateCollectionDialogOpen] =
    useState(false);
  const [newCollectionName, setNewCollectionName] = useState("");
  const [creatingCollection, setCreatingCollection] = useState(false);
  const [saveToCollectionModalOpen, setSaveToCollectionModalOpen] =
    useState(false);
  const [pendingRequestToSave, setPendingRequestToSave] = useState(null);

  // Environments state
  const [expandedEnvironments, setExpandedEnvironments] = useState(new Set());

  const toggleEnvironment = (envId) => {
    setExpandedEnvironments((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(envId)) {
        newSet.delete(envId);
      } else {
        newSet.add(envId);
      }
      return newSet;
    });
  };

  const handleCreateEnvironment = async () => {
    if (!newEnvironmentName.trim()) return;

    try {
      const newEnv = createEnvironment(newEnvironmentName, []);
      setEnvironments((prev) => ({ ...prev, [newEnv.id]: newEnv }));
      setCreateEnvironmentDialogOpen(false);
      setNewEnvironmentName("");
      setNewEnvironmentDescription("");
      setNewEnvironmentColor("blue");
    } catch (error) {
      console.error("Failed to create environment:", error);
    }
  };

  const handleDeleteEnvironment = async (envId) => {
    try {
      const updatedEnvironments = deleteEnvironment(envId);
      setEnvironments(updatedEnvironments);
      if (activeEnvironmentId === envId) {
        setActiveEnvironmentId("development");
      }
    } catch (error) {
      console.error("Failed to delete environment:", error);
    }
  };

  const handleEnvironmentSelect = (envId) => {
    setActiveEnvironment(envId);
    setActiveEnvironmentId(envId);
  };

  const handleAddVariable = (envId) => {
    setSelectedEnvironmentForVariable(envId);
    setNewVariableKey("");
    setNewVariableValue("");
    setNewVariableDescription("");
    setAddVariableDialogOpen(true);
  };

  const handleEditVariable = (envId, variableIndex, variable) => {
    setSelectedEnvironmentForVariable(envId);
    setSelectedVariableIndex(variableIndex);
    setNewVariableKey(variable.key);
    setNewVariableValue(variable.value);
    setNewVariableDescription(variable.description || "");
    setEditVariableDialogOpen(true);
  };

  const handleSaveNewVariable = async () => {
    if (!newVariableKey.trim() || !selectedEnvironmentForVariable) return;

    try {
      const updatedEnv = addVariableToEnvironment(
        selectedEnvironmentForVariable,
        {
          key: newVariableKey,
          value: newVariableValue,
          description: newVariableDescription,
        }
      );

      setEnvironments((prev) => ({ ...prev, [updatedEnv.id]: updatedEnv }));
      setAddVariableDialogOpen(false);
      setNewVariableKey("");
      setNewVariableValue("");
      setNewVariableDescription("");
    } catch (error) {
      console.error("Failed to add variable:", error);
    }
  };

  const handleSaveEditedVariable = async () => {
    if (
      !newVariableKey.trim() ||
      selectedVariableIndex === null ||
      !selectedEnvironmentForVariable
    )
      return;

    try {
      const updatedEnv = updateVariableInEnvironment(
        selectedEnvironmentForVariable,
        selectedVariableIndex,
        {
          key: newVariableKey,
          value: newVariableValue,
          description: newVariableDescription,
        }
      );

      setEnvironments((prev) => ({ ...prev, [updatedEnv.id]: updatedEnv }));
      setEditVariableDialogOpen(false);
      setNewVariableKey("");
      setNewVariableValue("");
      setNewVariableDescription("");
      setSelectedVariableIndex(null);
    } catch (error) {
      console.error("Failed to update variable:", error);
    }
  };

  const handleDeleteVariable = async (envId, variableIndex) => {
    try {
      const updatedEnv = deleteVariableFromEnvironment(envId, variableIndex);
      setEnvironments((prev) => ({ ...prev, [updatedEnv.id]: updatedEnv }));
    } catch (error) {
      console.error("Failed to delete variable:", error);
    }
  };
  const [editingEnvironment, setEditingEnvironment] = useState(null);

  // Request history state
  const [historyItems, setHistoryItems] = useState([]);
  const [historyLoading, setHistoryLoading] = useState(false);
  const [historySearchQuery, setHistorySearchQuery] = useState("");

  // Load request history when user changes or when history tab is active
  useEffect(() => {
    if (user && activeMenuTab === "history") {
      loadRequestHistory();
    } else if (!user) {
      setHistoryItems([]);
    }
  }, [user, activeMenuTab]);

  const loadRequestHistory = async () => {
    setHistoryLoading(true);
    try {
      const { getRequestHistory } = await import("@/lib/supabase-collections");
      const history = await getRequestHistory(50); // Get last 50 requests

      // Transform the data to match our UI format
      const transformedHistory = history.map((item) => ({
        id: item.id,
        name: generateRequestName(item.method, item.url),
        method: item.method,
        url: item.url,
        headers: item.headers,
        body: item.body,
        timestamp: formatTimeAgo(new Date(item.created_at)),
        status: item.response_status,
        responseTime: item.response_time,
        createdAt: item.created_at,
        responseHeaders: item.response_headers,
        responseBody: item.response_body,
      }));

      setHistoryItems(transformedHistory);
    } catch (error) {
      console.error("Failed to load request history:", error);
    } finally {
      setHistoryLoading(false);
    }
  };

  // Helper function to format time ago
  const formatTimeAgo = (date) => {
    const now = new Date();
    const diffInMinutes = Math.floor((now - date) / (1000 * 60));

    if (diffInMinutes < 1) return "Just now";
    if (diffInMinutes < 60) return `${diffInMinutes} min ago`;

    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24)
      return `${diffInHours} hour${diffInHours > 1 ? "s" : ""} ago`;

    const diffInDays = Math.floor(diffInHours / 24);
    return `${diffInDays} day${diffInDays > 1 ? "s" : ""} ago`;
  };

  // Filter history items based on search
  const filteredHistoryItems = historyItems.filter((item) => {
    if (!historySearchQuery.trim()) return true;
    const query = historySearchQuery.toLowerCase();
    return (
      item.name.toLowerCase().includes(query) ||
      item.method.toLowerCase().includes(query) ||
      item.url.toLowerCase().includes(query)
    );
  });

  // Calculate history analytics
  const historyAnalytics = {
    total: historyItems.length,
    successful: historyItems.filter(
      (item) => item.status >= 200 && item.status < 300
    ).length,
    failed: historyItems.filter((item) => item.status >= 400).length,
    avgResponseTime:
      historyItems.length > 0
        ? Math.round(
            historyItems.reduce(
              (acc, item) => acc + (item.responseTime || 0),
              0
            ) / historyItems.length
          )
        : 0,
    methods: historyItems.reduce((acc, item) => {
      acc[item.method] = (acc[item.method] || 0) + 1;
      return acc;
    }, {}),
    recentActivity: historyItems.slice(0, 5),
  };

  // Replay request from history
  const replayHistoryRequest = (historyItem) => {
    // Create a new tab with the request from history
    const newTabId = Date.now().toString();
    const newTab = {
      id: newTabId,
      name: historyItem.name + " (Replay)",
      request: {
        method: historyItem.method,
        url: historyItem.url,
        headers: historyItem.headers || {},
        body: historyItem.body || "",
      },
      response: null,
      loading: false,
      collectionRequestId: null,
      isModified: false,
    };

    setRequestTabs((prev) => [...prev, newTab]);
    setActiveTabId(newTabId);

    console.log("Replayed request from history:", historyItem.name);
  };

  // Clear request history
  const clearHistory = async () => {
    if (window.confirm("Are you sure you want to clear all request history?")) {
      setHistoryItems([]);
      // TODO: Add actual database clearing if needed
      console.log("Request history cleared");
    }
  };

  // Environment management state
  const [environments, setEnvironments] = useState({});
  const [activeEnvironmentId, setActiveEnvironmentId] = useState("development");
  const [createEnvironmentDialogOpen, setCreateEnvironmentDialogOpen] =
    useState(false);
  const [editingEnvironmentVariable, setEditingEnvironmentVariable] =
    useState(null);
  const [addVariableDialogOpen, setAddVariableDialogOpen] = useState(false);
  const [editVariableDialogOpen, setEditVariableDialogOpen] = useState(false);
  const [selectedEnvironmentForVariable, setSelectedEnvironmentForVariable] =
    useState(null);
  const [selectedVariableIndex, setSelectedVariableIndex] = useState(null);
  const [newEnvironmentName, setNewEnvironmentName] = useState("");
  const [newEnvironmentDescription, setNewEnvironmentDescription] =
    useState("");
  const [newEnvironmentColor, setNewEnvironmentColor] = useState("blue");
  const [newVariableKey, setNewVariableKey] = useState("");
  const [newVariableValue, setNewVariableValue] = useState("");
  const [newVariableDescription, setNewVariableDescription] = useState("");

  // Load environments on mount
  useEffect(() => {
    const loadedEnvironments = getEnvironments();
    setEnvironments(loadedEnvironments);
    setActiveEnvironmentId(getActiveEnvironment());
  }, []);

  // Get environments as array for display
  const environmentsArray = Object.values(environments);

  // Sample trash data
  const trashItems = [
    {
      id: "trash-1",
      name: "Old API Collection",
      type: "collection",
      deletedAt: "2 days ago",
    },
    {
      id: "trash-2",
      name: "Test Request",
      type: "request",
      method: "DELETE",
      deletedAt: "1 week ago",
    },
  ];

  // Collection management functions
  const toggleCollection = (collectionId) => {
    const newExpanded = new Set(expandedCollections);
    if (newExpanded.has(collectionId)) {
      newExpanded.delete(collectionId);
    } else {
      newExpanded.add(collectionId);
    }
    setExpandedCollections(newExpanded);
  };

  // Environment management functions

  // Sidebar menu items
  const sidebarMenuItems = [
    {
      id: "collections",
      icon: FolderOpen,
      label: "Collections",
      description: "Saved grouped requests",
    },
    {
      id: "history",
      icon: History,
      label: "History",
      description: "Past requests sent",
    },
    {
      id: "environments",
      icon: Globe,
      label: "Environments",
      description: "Manage variables like API keys, URLs, tokens",
    },
    {
      id: "trash",
      icon: Trash2,
      label: "Trash",
      description: "Deleted or outdated requests",
    },
  ];

  // Helper functions for tab management
  const getCurrentTab = () => requestTabs.find((tab) => tab.id === activeTabId);

  const updateCurrentTab = (updates) => {
    setRequestTabs((tabs) =>
      tabs.map((tab) =>
        tab.id === activeTabId ? { ...tab, ...updates, isModified: true } : tab
      )
    );
  };

  const createNewTab = () => {
    const newTabId = Date.now().toString();
    const newTab = {
      id: newTabId,
      name: "Untitled Request",
      request: {
        method: "GET",
        url: "",
        headers: {},
        body: "",
      },
      response: null,
      loading: false,
      collectionRequestId: null,
      isModified: false,
    };
    setRequestTabs((tabs) => [...tabs, newTab]);
    setActiveTabId(newTabId);
  };

  const closeTab = (tabId) => {
    if (requestTabs.length === 1) return; // Don't close the last tab

    setRequestTabs((tabs) => {
      const newTabs = tabs.filter((tab) => tab.id !== tabId);
      // If we're closing the active tab, switch to the previous one
      if (tabId === activeTabId) {
        const activeIndex = tabs.findIndex((tab) => tab.id === tabId);
        const newActiveIndex = activeIndex > 0 ? activeIndex - 1 : 0;
        setActiveTabId(newTabs[newActiveIndex].id);
      }
      return newTabs;
    });
  };

  // Load shared request and active collection on mount
  useEffect(() => {
    const sharedRequest = getSharedRequest();
    if (sharedRequest) {
      updateCurrentTab({ request: sharedRequest });
      setShowShared(true);
      setTimeout(() => setShowShared(false), 3000);
    }

    // Load active collection
    const activeColId = activeCollectionId;
    setActiveCollectionId(activeColId);
  }, []);

  // Get current tab data
  const currentTab = getCurrentTab();
  const request = {
    method: "GET",
    url: "",
    headers: {},
    body: "",
    ...currentTab?.request,
  };
  const response = currentTab?.response || null;
  const loading = currentTab?.loading || false;

  const handleSaveRequest = () => {
    // Use the same logic as the keyboard shortcut - will show modal if needed
    saveCurrentRequestToCollection();
  };

  const executeRequest = async () => {
    updateCurrentTab({ loading: true });
    try {
      // Process request with environment variables
      const processedRequest = processRequestWithVariables(request);

      const options = {
        method: processedRequest.method,
        headers: {
          "Content-Type": "application/json",
          ...processedRequest.headers,
        },
      };

      if (processedRequest.method !== "GET" && processedRequest.body) {
        options.body = processedRequest.body;
      }

      const startTime = Date.now();
      const res = await fetch(processedRequest.url, options);
      const endTime = Date.now();

      const data = await res.text();
      let parsedData = data;

      try {
        parsedData = JSON.parse(data);
      } catch (e) {
        // Keep as text if not JSON
      }

      const responseData = {
        status: res.status,
        statusText: res.statusText,
        headers: Object.fromEntries(res.headers.entries()),
        data: parsedData,
        time: endTime - startTime,
        size: new Blob([data]).size,
      };

      updateCurrentTab({ response: responseData, loading: false });

      // Save to history (adjust format for database)
      const historyResponse = {
        ...responseData,
        body: responseData.data,
        responseTime: responseData.time,
      };
      saveToHistory(request, historyResponse);

      // Refresh history if user is viewing history tab
      if (activeMenuTab === "history") {
        loadRequestHistory();
      }
    } catch (error) {
      const errorResponse = {
        error: error.message,
        status: 0,
        time: 0,
      };

      updateCurrentTab({ response: errorResponse, loading: false });

      // Save failed requests to history too (adjust format for database)
      const historyErrorResponse = {
        ...errorResponse,
        body: errorResponse.error,
        responseTime: errorResponse.time,
      };
      saveToHistory(request, historyErrorResponse);

      // Refresh history if user is viewing history tab
      if (activeMenuTab === "history") {
        loadRequestHistory();
      }
    }
  };

  const handleShare = () => {
    const url = generateShareableUrl(request);
    if (url) {
      setShareUrl(url);
      setShareDialogOpen(true);
    }
  };

  const copyShareUrl = async () => {
    try {
      await navigator.clipboard.writeText(shareUrl);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (err) {
      console.error("Failed to copy to clipboard:", err);
    }
  };

  const handleCreateCollection = async () => {
    if (!newCollectionName.trim()) return;

    setCreatingCollection(true);
    try {
      console.log("Creating collection:", newCollectionName);
      await createCollection(newCollectionName, "", "blue");
      setCreateCollectionDialogOpen(false);
      setNewCollectionName("");
    } catch (err) {
      console.error("Failed to create collection:", err);
    } finally {
      setCreatingCollection(false);
    }
  };

  const handleDeleteCollection = async (collectionId, collectionName) => {
    if (
      window.confirm(
        `Are you sure you want to delete "${collectionName}"? This will also delete all requests in this collection.`
      )
    ) {
      try {
        console.log("Deleting collection:", collectionId);
        await deleteCollection(collectionId);
      } catch (err) {
        console.error("Failed to delete collection:", err);
      }
    }
  };

  const handleCreateRequest = async (collectionId) => {
    try {
      console.log("Creating new request in collection:", collectionId);

      // Create a new request object
      const newRequest = {
        name: "Untitled Request",
        description: "",
        method: "GET",
        url: "",
        headers: {},
        body: "",
        tags: [],
      };

      // Add the request to the collection in the database
      const savedRequest = await addRequestToCollection(
        collectionId,
        newRequest
      );

      // Create a new tab with this request
      const newTabId = Date.now().toString();
      const newTab = {
        id: newTabId,
        name: savedRequest.name,
        request: {
          method: savedRequest.method,
          url: savedRequest.url,
          headers: savedRequest.headers || {},
          body: savedRequest.body || "",
        },
        response: null,
        loading: false,
        collectionRequestId: savedRequest.id,
        isModified: false,
      };

      // Add the new tab and make it active
      setRequestTabs((prev) => [...prev, newTab]);
      setActiveTabId(newTabId);

      // Expand the collection to show the new request
      setExpandedCollections((prev) => new Set(prev).add(collectionId));

      console.log("New request created and tab opened:", savedRequest);
    } catch (err) {
      console.error("Failed to create request:", err);
    }
  };

  const handleEditCollection = (collectionId) => {
    setEditingCollection(collectionId);
  };

  const handleDuplicateCollection = async (collection) => {
    try {
      console.log("Duplicating collection:", collection.name);
      const duplicatedName = `${collection.name} Copy`;
      await createCollection(
        duplicatedName,
        collection.description,
        collection.color
      );
      // TODO: Also duplicate the requests in the collection
    } catch (err) {
      console.error("Failed to duplicate collection:", err);
    }
  };

  const handleRequestClick = (request) => {
    console.log("Opening request in new tab:", request.name);

    // Check if request is already open in a tab
    const existingTab = requestTabs.find(
      (tab) => tab.collectionRequestId === request.id
    );

    if (existingTab) {
      // If tab exists, just switch to it
      setActiveTabId(existingTab.id);
      return;
    }

    // Create a new tab with this request
    const newTabId = Date.now().toString();
    const newTab = {
      id: newTabId,
      name: request.name,
      request: {
        method: request.method,
        url: request.url,
        headers: request.headers || {},
        body: request.body || "",
      },
      response: null,
      loading: false,
      collectionRequestId: request.id,
      isModified: false,
    };

    // Add the new tab and make it active
    setRequestTabs((prev) => [...prev, newTab]);
    setActiveTabId(newTabId);
  };

  // Request modification handlers
  const setRequest = (newRequest) => {
    const currentTab = getCurrentTab();
    const updates = { request: newRequest, isModified: true };

    // Auto-update name if it's auto-generated and URL or method changed
    if (
      currentTab &&
      currentTab.request &&
      isAutoGeneratedName(currentTab.name)
    ) {
      const urlChanged = currentTab.request.url !== newRequest.url;
      const methodChanged = currentTab.request.method !== newRequest.method;

      if (urlChanged || methodChanged) {
        const newName = generateRequestName(newRequest.method, newRequest.url);
        updates.name = newName;
        console.log("Auto-updating request name:", newName);
      }
    }

    updateCurrentTab(updates);
  };

  const setCurrentRequestName = (name) => {
    updateCurrentTab({ name, isModified: true });
  };

  // Auto-save request changes to collection
  const saveCurrentRequestToCollection = async () => {
    const currentTab = requestTabs.find((tab) => tab.id === activeTabId);
    if (!currentTab || !currentTab.request) {
      return;
    }

    // If request has no collection association, show the save modal
    if (!currentTab.collectionRequestId) {
      setPendingRequestToSave(currentTab);
      setSaveToCollectionModalOpen(true);
      return;
    }

    // If not modified, no need to save
    if (!currentTab.isModified) {
      return;
    }

    try {
      // Find which collection this request belongs to
      let collectionId = null;
      for (const [colId, collection] of Object.entries(collections)) {
        if (
          collection.requests?.some(
            (req) => req.id === currentTab.collectionRequestId
          )
        ) {
          collectionId = colId;
          break;
        }
      }

      if (!collectionId) {
        throw new Error("Could not find collection for this request");
      }

      const updatedRequest = {
        name: currentTab.name,
        method: currentTab.request?.method || "GET",
        url: currentTab.request?.url || "",
        headers: currentTab.request?.headers || {},
        body: currentTab.request?.body || "",
      };

      await updateRequestInCollection(
        collectionId,
        currentTab.collectionRequestId,
        updatedRequest
      );

      // Mark as saved
      updateCurrentTab({ isModified: false });

      console.log("Request saved to collection");
    } catch (err) {
      console.error("Failed to save request to collection:", err);
    }
  };

  // Handle saving request to selected collection
  const handleSaveToCollection = async (collectionId) => {
    if (!pendingRequestToSave) return;

    try {
      // Generate a better name if the current one is auto-generated or empty
      let requestName = pendingRequestToSave.name || "Untitled Request";
      if (
        isAutoGeneratedName(requestName) &&
        pendingRequestToSave.request?.url
      ) {
        requestName = generateRequestName(
          pendingRequestToSave.request.method,
          pendingRequestToSave.request.url
        );
      }

      const requestData = {
        name: requestName,
        description: "",
        method: pendingRequestToSave.request?.method || "GET",
        url: pendingRequestToSave.request?.url || "",
        headers: pendingRequestToSave.request?.headers || {},
        body: pendingRequestToSave.request?.body || "",
        tags: [],
      };

      const savedRequest = await addRequestToCollection(
        collectionId,
        requestData
      );

      // Update the tab to link it to the saved request and update name
      setRequestTabs((prev) =>
        prev.map((tab) =>
          tab.id === pendingRequestToSave.id
            ? {
                ...tab,
                name: savedRequest.name,
                collectionRequestId: savedRequest.id,
                isModified: false,
              }
            : tab
        )
      );

      // Close modal and clear pending request
      setSaveToCollectionModalOpen(false);
      setPendingRequestToSave(null);

      console.log("Request saved to collection:", savedRequest);
    } catch (err) {
      console.error("Failed to save request to collection:", err);
    }
  };

  // Save tabs to localStorage whenever they change (but only after initialization)
  useEffect(() => {
    if (tabsInitialized && requestTabs.length > 0) {
      const tabsToSave = {
        tabs: requestTabs,
        activeTabId: activeTabId,
        timestamp: Date.now(),
      };
      localStorage.setItem("api-playground-tabs", JSON.stringify(tabsToSave));
      console.log("Tabs saved to localStorage:", tabsToSave);
    }
  }, [requestTabs, activeTabId, tabsInitialized]);

  // Restore tabs from localStorage on component mount
  useEffect(() => {
    let restored = false;

    try {
      const savedTabsData = localStorage.getItem("api-playground-tabs");
      if (savedTabsData) {
        const {
          tabs,
          activeTabId: savedActiveTabId,
          timestamp,
        } = JSON.parse(savedTabsData);

        // Only restore if data is less than 7 days old
        const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;
        if (
          timestamp &&
          Date.now() - timestamp < sevenDaysInMs &&
          tabs &&
          tabs.length > 0
        ) {
          console.log("Restoring tabs from localStorage:", {
            tabs,
            savedActiveTabId,
          });
          setRequestTabs(tabs);
          if (
            savedActiveTabId &&
            tabs.some((tab) => tab.id === savedActiveTabId)
          ) {
            setActiveTabId(savedActiveTabId);
          } else {
            setActiveTabId(tabs[0].id);
          }
          restored = true;
        } else {
          console.log(
            "Saved tabs are too old or invalid, removing from storage"
          );
          localStorage.removeItem("api-playground-tabs");
        }
      }
    } catch (err) {
      console.error("Failed to restore tabs from localStorage:", err);
      localStorage.removeItem("api-playground-tabs");
    }

    // If no tabs were restored, create a default tab
    if (!restored) {
      console.log("No saved tabs found, creating default tab");
      const defaultUrl = "https://jsonplaceholder.typicode.com/posts/1";
      const defaultTab = {
        id: "1",
        name: generateRequestName("GET", defaultUrl),
        request: {
          method: "GET",
          url: defaultUrl,
          headers: {},
          body: "",
        },
        response: null,
        loading: false,
        collectionRequestId: null,
        isModified: false,
      };
      setRequestTabs([defaultTab]);
      setActiveTabId("1");
    }

    setTabsInitialized(true);
  }, []); // Only run on mount

  // Keyboard shortcuts (Ctrl+S / Cmd+S for save, Ctrl+Enter / Cmd+Enter for send)
  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "s") {
        e.preventDefault();
        saveCurrentRequestToCollection();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        if (request.url && !loading) {
          executeRequest();
        }
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [activeTabId, requestTabs, request.url, loading]);

  // Don't render until tabs are initialized
  if (!tabsInitialized) {
    return (
      <div
        className={`min-h-screen flex items-center justify-center ${themeClasses.bg.primary}`}
      >
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-400 mx-auto mb-2"></div>
          <p className={`text-sm ${themeClasses.text.secondary}`}>Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div
      className={`min-h-screen transition-colors duration-300 ${themeClasses.bg.primary} ${themeClasses.text.primary}`}
    >
      {/* Header - Theme Aware */}
      <header
        className={`border-b ${themeClasses.border.primary} ${themeClasses.bg.glass} h-14 flex items-center px-3 sm:px-6 transition-all duration-300 relative z-50`}
      >
        <div className="flex items-center space-x-2 sm:space-x-6 min-w-0 flex-shrink-0">
          {/* Mobile Hamburger Menu */}
          <button
            onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
            className="lg:hidden p-1.5 transition-all duration-200 hover:bg-gray-50"
            style={{ borderRadius: "6px" }}
          >
            <svg
              className="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
          </button>

          <div className="flex items-center space-x-2 sm:space-x-3">
            <div
              className="h-6 w-6 sm:h-8 sm:w-8 flex items-center justify-center"
              style={{ borderRadius: "6px", backgroundColor: "#171717" }}
            >
              <Zap className="h-3 w-3 sm:h-4 sm:w-4 text-white" />
            </div>
            <h1 className="text-sm sm:text-lg font-bold tracking-tight text-gray-900 dark:text-white hidden sm:block">
              API Playground
            </h1>
            <h1 className="text-sm font-bold tracking-tight text-gray-900 dark:text-white sm:hidden">
              API
            </h1>
          </div>
        </div>

        <div className="flex items-center space-x-1 sm:space-x-3 ml-auto">
          {/* Search Input */}
          <div className="relative z-[99999] search-container">
            <div
              className={`transition-all duration-300 ${
                searchModalOpen ? "w-64 sm:w-80" : "w-32 sm:w-40"
              }`}
            >
              <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-500 z-10" />
              <Input
                placeholder={
                  searchModalOpen
                    ? "Search collections, requests, environments..."
                    : "Find..."
                }
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onFocus={() => setSearchModalOpen(true)}
                className="pl-10 py-1.5 text-sm focus:ring-0 focus:outline-none cursor-pointer transition-all duration-300"
                style={{
                  borderRadius: "6px",
                  borderColor: "rgb(235, 235, 235)",
                  backgroundColor: "white",
                  border: "1px solid rgb(235, 235, 235)",
                  boxShadow: "none",
                }}
              />

              {/* Search Dropdown */}
              {searchModalOpen && (
                <div
                  className="absolute top-full right-0 mt-2 w-80 bg-white border shadow-xs max-h-96 overflow-y-auto z-[99999]"
                  style={{
                    borderRadius: "6px",
                    borderColor: "rgb(235, 235, 235)",
                  }}
                >
                  {searchQuery.length > 0 ? (
                    <div className="p-4">
                      <p className="text-sm text-gray-500 mb-3">
                        Search results for "{searchQuery}"
                      </p>
                      <div className="space-y-2">
                        <div
                          className="p-3 hover:bg-gray-50 cursor-pointer"
                          style={{ borderRadius: "6px" }}
                        >
                          <div className="font-medium text-sm">
                            Example Collection
                          </div>
                          <div className="text-xs text-gray-500">
                            Collection • 5 requests
                          </div>
                        </div>
                        <div
                          className="p-3 hover:bg-gray-50 cursor-pointer"
                          style={{ borderRadius: "6px" }}
                        >
                          <div className="font-medium text-sm">
                            API Request Example
                          </div>
                          <div className="text-xs text-gray-500">
                            Request • GET /api/users
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="p-6 text-center text-gray-500">
                      <Search className="h-6 w-6 mx-auto mb-2 opacity-40" />
                      <p className="text-sm">Start typing to search...</p>
                      <p className="text-xs text-gray-400 mt-1">
                        Find collections, requests, and environments
                      </p>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>

          {/* Import/Export Button */}
          <button
            onClick={() => setShowImportExportModal(true)}
            className="px-3 py-1.5 text-sm transition-all duration-200 hover:bg-gray-50 border cursor-pointer"
            style={{
              borderRadius: "6px",
              borderColor: "rgb(235, 235, 235)",
              backgroundColor: "white",
            }}
            title="Import/Export Collections"
          >
            <span className="text-gray-600 text-sm font-medium">
              Import/Export
            </span>
          </button>

          {/* Layout Toggle Button */}
          <button
            onClick={() =>
              setLayoutMode(layoutMode === "single" ? "split" : "single")
            }
            className="p-2 transition-all duration-200 hover:bg-gray-50 dark:hover:bg-gray-800 border cursor-pointer"
            style={{
              borderRadius: "50%",
              borderColor: "rgb(235, 235, 235)",
            }}
            title={
              layoutMode === "single"
                ? "Switch to split layout"
                : "Switch to single column layout"
            }
          >
            {layoutMode === "single" ? (
              <SplitSquareHorizontal className="h-4 w-4" />
            ) : (
              <Columns className="h-4 w-4" />
            )}
          </button>

          <button
            onClick={toggleTheme}
            className="p-2 transition-all duration-200 hover:bg-gray-50 dark:hover:bg-gray-800 border cursor-pointer"
            style={{
              borderRadius: "50%",
              borderColor: "rgb(235, 235, 235)",
            }}
          >
            {isDark ? (
              <Sun className="h-4 w-4" />
            ) : (
              <Moon className="h-4 w-4" />
            )}
          </button>

          {/* User Avatar/Auth Section */}
          {authLoading ? (
            <div className="h-8 w-8 rounded bg-gray-200 dark:bg-gray-700 animate-pulse" />
          ) : user ? (
            <div className="relative group">
              <UserAvatar user={user} isDark={isDark} />

              {/* Dropdown Menu */}
              <div
                className="fixed right-4 mt-2 w-48 bg-white dark:bg-gray-800 shadow-xl border opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-[99999]"
                style={{
                  borderRadius: "12px",
                  borderColor: "rgb(235, 235, 235)",
                  top: "60px",
                }}
              >
                <div
                  className="p-3 border-b"
                  style={{ borderColor: "rgb(235, 235, 235)" }}
                >
                  <p className="text-sm font-medium text-gray-900 dark:text-white">
                    {user.user_metadata?.full_name || "User"}
                  </p>
                  <p className="text-xs text-gray-500 dark:text-gray-400 truncate">
                    {user.email}
                  </p>
                </div>
                <div className="p-1">
                  <button
                    onClick={() => signOut()}
                    className="w-full text-left px-3 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                    style={{ borderRadius: "6px" }}
                  >
                    Sign out
                  </button>
                </div>
              </div>
            </div>
          ) : (
            <button
              onClick={() => (window.location.href = "/login")}
              className="h-8 px-3 text-xs font-medium transition-all duration-200 text-white"
              style={{
                borderRadius: "6px",
                backgroundColor: "#171717",
                border: "none",
              }}
            >
              Sign in
            </button>
          )}
        </div>
      </header>

      {/* Main Content Layout - Theme Aware */}
      <div className="flex h-[calc(100vh-3.5rem)] relative">
        {/* Mobile Sidebar Overlay */}
        {!sidebarCollapsed && (
          <div
            className="fixed inset-0 bg-black/50 z-40 lg:hidden"
            onClick={() => setSidebarCollapsed(true)}
          />
        )}

        <div
          data-sidebar-container
          className={`${
            sidebarCollapsed 
              ? "w-16 lg:w-16" 
              : `lg:w-[${56 + (sidebarContentOpen ? sidebarContentWidth : 0)}px]`
          } ${
            sidebarCollapsed
              ? "-translate-x-full lg:translate-x-0"
              : "translate-x-0"
          } w-72 fixed lg:relative top-[3.5rem] lg:top-0 left-0 h-[calc(100vh-3.5rem)] lg:h-full border-r ${
            themeClasses.border.primary
          } ${
            themeClasses.bg.glass
          } ${
            isSidebarResizing ? "" : "transition-all duration-300"
          } z-50 lg:z-auto`}
          style={!sidebarCollapsed ? { width: `${56 + (sidebarContentOpen ? sidebarContentWidth : 0)}px` } : {}}
        >
          <TwoPanelSidebar
            sidebarCollapsed={sidebarCollapsed}
            setSidebarCollapsed={setSidebarCollapsed}
            themeClasses={themeClasses}
            isDark={isDark}
            sidebarMenuItems={sidebarMenuItems}
            activeMenuTab={activeMenuTab}
            onNavItemClick={handleNavItemClick}
            contentOpen={sidebarContentOpen}
            contentWidth={sidebarContentWidth}
            onResizeStart={handleSidebarResizeStart}
            isResizing={isSidebarResizing}
            collections={collections}
            expandedCollections={expandedCollections}
            toggleCollection={toggleCollection}
            editingCollection={editingCollection}
            setEditingCollection={setEditingCollection}
            updateCollection={(collectionId, updates) => {
              // Handle collection update
              console.log("Updating collection:", collectionId, updates);
            }}
            deleteCollection={handleDeleteCollection}
            history={filteredHistoryItems}
            loadRequest={(request) => {
              // Handle loading request from history/collections
              const newTabId = Date.now().toString();
              const newTab = {
                id: newTabId,
                name: request.name || "Untitled Request",
                request: {
                  method: request.method || "GET",
                  url: request.url || "",
                  headers: request.headers || {},
                  body: request.body || "",
                },
                response: null,
                loading: false,
                collectionRequestId: request.id || null,
                isModified: false,
              };
              setRequestTabs((prev) => [...prev, newTab]);
              setActiveTabId(newTabId);
            }}
            clearHistory={clearHistory}
            setNewRequestType={(type) => {
              console.log("Setting new request type:", type);
            }}
            setRequest={setRequest}
            setActiveTab={setActiveTabId}
            openTabs={requestTabs}
            setOpenTabs={setRequestTabs}
            setCreateCollectionDialogOpen={setCreateCollectionDialogOpen}
          />
        </div>

        {/* Main Content Area - Theme Aware Layout */}
        <div
          data-layout-container
          className={`flex-1 flex ${
            layoutMode === "single" ? "flex-col" : "flex-col lg:flex-row"
          } ${themeClasses.bg.primary} transition-colors duration-300 ${
            isDragging
              ? layoutMode === "single"
                ? "cursor-row-resize"
                : "cursor-col-resize"
              : ""
          }`}
        >
          {layoutMode === "split" ? (
            <>
              {/* Request Panel with dynamic width */}
              <div style={{ width: `${requestPanelWidth}%` }}>
                <RequestPanel request={request} setRequest={setRequest} />
              </div>

              {/* Horizontal Draggable Divider */}
              <div
                className={`bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-col-resize transition-colors duration-200 ${
                  isDragging ? "bg-gray-300 dark:bg-gray-600" : ""
                }`}
                onMouseDown={handleMouseDown}
                style={{ width: "2px" }}
              >
                <div
                  className="w-full h-full flex items-center justify-center"
                  style={{ height: "10px" }}
                >
                  <GripVertical className="h-4 w-4 text-gray-400 opacity-0 hover:opacity-100 transition-opacity" />
                </div>
              </div>

              {/* Response Panel with remaining width */}
              <div style={{ width: `${100 - requestPanelWidth}%` }}>
                <ResponsePanel
                  response={response}
                  loading={loading}
                  request={request}
                />
              </div>
            </>
          ) : (
            <>
              {/* Request Panel with dynamic height */}
              <div style={{ height: `${requestPanelHeight}%` }}>
                <RequestPanel request={request} setRequest={setRequest} />
              </div>

              {/* Vertical Draggable Divider */}
              <div
                className={`bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 cursor-row-resize transition-colors duration-200 ${
                  isDragging ? "bg-gray-300 dark:bg-gray-600" : ""
                }`}
                onMouseDown={handleMouseDown}
                style={{ height: "2px" }}
              >
                <div className="w-full h-full flex items-center justify-center">
                  <GripHorizontal className="h-4 w-4 text-gray-400 opacity-0 hover:opacity-100 transition-opacity" />
                </div>
              </div>

              {/* Response Panel with remaining height */}
              <div style={{ height: `${100 - requestPanelHeight}%` }}>
                <ResponsePanel
                  response={response}
                  loading={loading}
                  request={request}
                />
              </div>
            </>
          )}
        </div>
      </div>

      {/* Create Environment Dialog */}
      <Dialog
        open={createEnvironmentDialogOpen}
        onOpenChange={setCreateEnvironmentDialogOpen}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              Create Environment
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-3 pt-3">
            <div>
              <Input
                placeholder="Environment name"
                value={newEnvironmentName}
                onChange={(e) => setNewEnvironmentName(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
                onKeyPress={(e) => {
                  if (e.key === "Enter") {
                    handleCreateEnvironment();
                  }
                }}
              />
            </div>
            <div>
              <Input
                placeholder="Description (optional)"
                value={newEnvironmentDescription}
                onChange={(e) => setNewEnvironmentDescription(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
              />
            </div>
            <div className="flex justify-end gap-2 pt-1">
              <Button
                variant="outline"
                onClick={() => setCreateEnvironmentDialogOpen(false)}
                size="sm"
                className="px-3 text-xs"
              >
                Cancel
              </Button>
              <Button
                onClick={handleCreateEnvironment}
                size="sm"
                className="px-3 text-xs"
                disabled={!newEnvironmentName.trim()}
              >
                Create
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Add Variable Dialog */}
      <Dialog
        open={addVariableDialogOpen}
        onOpenChange={setAddVariableDialogOpen}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              Add Variable
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-3 pt-3">
            <div>
              <Input
                placeholder="Variable key (e.g., API_KEY)"
                value={newVariableKey}
                onChange={(e) => setNewVariableKey(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
              />
            </div>
            <div>
              <Input
                placeholder="Variable value"
                value={newVariableValue}
                onChange={(e) => setNewVariableValue(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
                type={
                  newVariableKey.toLowerCase().includes("key") ||
                  newVariableKey.toLowerCase().includes("token") ||
                  newVariableKey.toLowerCase().includes("secret")
                    ? "password"
                    : "text"
                }
              />
            </div>
            <div>
              <Input
                placeholder="Description (optional)"
                value={newVariableDescription}
                onChange={(e) => setNewVariableDescription(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
              />
            </div>
            <div className="flex justify-end gap-2 pt-1">
              <Button
                variant="outline"
                onClick={() => setAddVariableDialogOpen(false)}
                size="sm"
                className="px-3 text-xs"
              >
                Cancel
              </Button>
              <Button
                onClick={handleSaveNewVariable}
                size="sm"
                className="px-3 text-xs"
                disabled={!newVariableKey.trim()}
              >
                Add
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Edit Variable Dialog */}
      <Dialog
        open={editVariableDialogOpen}
        onOpenChange={setEditVariableDialogOpen}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              Edit Variable
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-3 pt-3">
            <div>
              <Input
                placeholder="Variable key (e.g., API_KEY)"
                value={newVariableKey}
                onChange={(e) => setNewVariableKey(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
              />
            </div>
            <div>
              <Input
                placeholder="Variable value"
                value={newVariableValue}
                onChange={(e) => setNewVariableValue(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
                type={
                  newVariableKey.toLowerCase().includes("key") ||
                  newVariableKey.toLowerCase().includes("token") ||
                  newVariableKey.toLowerCase().includes("secret")
                    ? "password"
                    : "text"
                }
              />
            </div>
            <div>
              <Input
                placeholder="Description (optional)"
                value={newVariableDescription}
                onChange={(e) => setNewVariableDescription(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
              />
            </div>
            <div className="flex justify-end gap-2 pt-1">
              <Button
                variant="outline"
                onClick={() => setEditVariableDialogOpen(false)}
                size="sm"
                className="px-3 text-xs"
              >
                Cancel
              </Button>
              <Button
                onClick={handleSaveEditedVariable}
                size="sm"
                className="px-3 text-xs"
                disabled={!newVariableKey.trim()}
              >
                Save
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Docs Generator Modal */}
      <DocGeneratorModal
        open={docsModalOpen}
        onOpenChange={(open) => {
          setDocsModalOpen(open);
          if (!open) {
            setSelectedCollectionForDocs(null);
          }
        }}
        collections={getCollectionsWithDocs()}
        preSelectedCollectionId={selectedCollectionForDocs}
        onGenerate={(docData) => {
          console.log("Generated docs with data:", docData);
          setDocsModalOpen(false);
          setSelectedCollectionForDocs(null);
        }}
      />

      {/* Settings Modal */}
      <Dialog open={settingsModalOpen} onOpenChange={setSettingsModalOpen}>
        <DialogContent
          className={`max-w-2xl max-h-[80vh] overflow-y-auto ${
            isDark ? "bg-gray-900 border-gray-700" : "bg-white border-gray-200"
          }`}
        >
          <DialogHeader>
            <DialogTitle
              className={`text-xl font-semibold ${themeClasses.text.primary}`}
            >
              Settings & Preferences
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-6">
            {/* Appearance Section */}
            <div>
              <h3
                className={`text-sm font-semibold mb-3 ${themeClasses.text.primary}`}
              >
                Appearance
              </h3>
              <div className="space-y-3">
                <div className={`p-4 rounded-lg ${themeClasses.card.base}`}>
                  <div className="flex items-center justify-between">
                    <div>
                      <p
                        className={`text-sm font-medium ${themeClasses.text.primary}`}
                      >
                        Theme
                      </p>
                      <p className={`text-xs ${themeClasses.text.tertiary}`}>
                        Choose your preferred color scheme
                      </p>
                    </div>
                    <button
                      onClick={toggleTheme}
                      className={`p-2 rounded transition-all duration-200 ${themeClasses.button.ghost}`}
                    >
                      {isDark ? (
                        <Sun className="h-4 w-4" />
                      ) : (
                        <Moon className="h-4 w-4" />
                      )}
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {/* Editor Section */}
            <div>
              <h3
                className={`text-sm font-semibold mb-3 ${themeClasses.text.primary}`}
              >
                Editor
              </h3>
              <div className="space-y-3">
                <div className={`p-4 rounded-lg ${themeClasses.card.base}`}>
                  <div className="flex items-center justify-between">
                    <div>
                      <p
                        className={`text-sm font-medium ${themeClasses.text.primary}`}
                      >
                        Font Size
                      </p>
                      <p className={`text-xs ${themeClasses.text.tertiary}`}>
                        Adjust the editor font size
                      </p>
                    </div>
                    <select
                      className={`px-3 py-1 rounded text-sm ${themeClasses.input.base}`}
                    >
                      <option value="12">12px</option>
                      <option value="14" selected>
                        14px
                      </option>
                      <option value="16">16px</option>
                    </select>
                  </div>
                </div>
                <div className={`p-4 rounded-lg ${themeClasses.card.base}`}>
                  <div className="flex items-center justify-between">
                    <div>
                      <p
                        className={`text-sm font-medium ${themeClasses.text.primary}`}
                      >
                        Auto-save
                      </p>
                      <p className={`text-xs ${themeClasses.text.tertiary}`}>
                        Automatically save changes
                      </p>
                    </div>
                    <button
                      className={`w-10 h-6 rounded-full transition-colors ${
                        isDark ? "bg-blue-600" : "bg-blue-500"
                      } relative`}
                    >
                      <div className="w-4 h-4 bg-white rounded-full absolute top-1 right-1 transition-transform"></div>
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {/* API Section */}
            <div>
              <h3
                className={`text-sm font-semibold mb-3 ${themeClasses.text.primary}`}
              >
                API Defaults
              </h3>
              <div className="space-y-3">
                <div className={`p-4 rounded-lg ${themeClasses.card.base}`}>
                  <label
                    className={`text-sm font-medium ${themeClasses.text.primary}`}
                  >
                    Default Base URL
                  </label>
                  <input
                    type="text"
                    placeholder="https://api.example.com"
                    className={`w-full mt-2 px-3 py-2 text-sm rounded ${themeClasses.input.base}`}
                  />
                </div>
                <div className={`p-4 rounded-lg ${themeClasses.card.base}`}>
                  <label
                    className={`text-sm font-medium ${themeClasses.text.primary}`}
                  >
                    Request Timeout (ms)
                  </label>
                  <input
                    type="number"
                    placeholder="5000"
                    className={`w-full mt-2 px-3 py-2 text-sm rounded ${themeClasses.input.base}`}
                  />
                </div>
              </div>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Create Collection Dialog */}
      <Dialog
        open={createCollectionDialogOpen}
        onOpenChange={setCreateCollectionDialogOpen}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              Create Collection
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-3 pt-3">
            <div>
              <Input
                placeholder="Collection name"
                value={newCollectionName}
                onChange={(e) => setNewCollectionName(e.target.value)}
                className="h-8 text-sm border-gray-200 focus:border-gray-300 focus:ring-0"
                disabled={creatingCollection}
                onKeyPress={(e) => {
                  if (e.key === "Enter") {
                    handleCreateCollection();
                  }
                }}
              />
            </div>
            <div className="flex justify-end gap-2 pt-1">
              <Button
                variant="outline"
                onClick={() => setCreateCollectionDialogOpen(false)}
                size="sm"
                className="px-3 text-xs"
                disabled={creatingCollection}
              >
                Cancel
              </Button>
              <Button
                onClick={handleCreateCollection}
                disabled={!newCollectionName.trim() || creatingCollection}
                size="sm"
                className="px-3 text-xs bg-black hover:bg-gray-800 text-white"
              >
                {creatingCollection ? (
                  <>
                    <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                    Creating...
                  </>
                ) : (
                  "Create"
                )}
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Save to Collection Modal */}
      <Dialog
        open={saveToCollectionModalOpen}
        onOpenChange={setSaveToCollectionModalOpen}
      >
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle className="text-base font-medium">
              Save Request
            </DialogTitle>
          </DialogHeader>
          <div className="space-y-4 pt-3">
            <div>
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                Choose a collection to save this request to:
              </p>

              <div className="space-y-2 max-h-64 overflow-y-auto">
                {Object.values(collections).map((collection) => (
                  <button
                    key={collection.id}
                    onClick={() => handleSaveToCollection(collection.id)}
                    className="w-full text-left p-3 rounded-lg border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div className="h-8 w-8 rounded bg-blue-100 dark:bg-blue-900 flex items-center justify-center">
                        <FolderOpen className="h-4 w-4 text-blue-600 dark:text-blue-400" />
                      </div>
                      <div>
                        <div className="font-medium text-gray-900 dark:text-gray-100">
                          {collection.name}
                        </div>
                        {collection.description && (
                          <div className="text-xs text-gray-500 dark:text-gray-400">
                            {collection.description}
                          </div>
                        )}
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </div>

            <div className="flex justify-end gap-2 pt-2 border-t border-gray-200 dark:border-gray-700">
              <Button
                variant="outline"
                onClick={() => setSaveToCollectionModalOpen(false)}
                size="sm"
                className="px-3 text-xs"
              >
                Cancel
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Import/Export Modal */}
      <Dialog
        open={showImportExportModal}
        onOpenChange={setShowImportExportModal}
      >
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Import/Export Collections</DialogTitle>
          </DialogHeader>

          <div className="space-y-6">
            {/* Export Section */}
            <div className="space-y-3">
              <h3 className="text-sm font-medium">Export Current Request</h3>
              <p className="text-xs text-gray-600 dark:text-gray-400">
                Export your current request as a Postman collection
              </p>
              <Button
                onClick={() => {
                  // Parse URL to extract components
                  let urlParts = {
                    protocol: "https",
                    host: [],
                    path: [],
                    query: [],
                  };
                  if (request.url) {
                    try {
                      const url = new URL(request.url);
                      urlParts.protocol = url.protocol.replace(":", "");
                      urlParts.host = url.hostname.split(".");
                      urlParts.path = url.pathname.split("/").filter((p) => p);

                      // Extract query parameters
                      url.searchParams.forEach((value, key) => {
                        urlParts.query.push({ key, value });
                      });
                    } catch (e) {
                      // Fallback for invalid URLs
                      urlParts.host = ["localhost"];
                      urlParts.path = [];
                    }
                  }

                  const collection = {
                    info: {
                      _postman_id: crypto.randomUUID(),
                      name: "API Playground Export",
                      schema:
                        "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
                      _exporter_id: "api-playground",
                    },
                    item: [
                      {
                        name: request.name || "Untitled Request",
                        request: {
                          method: request.method || "GET",
                          header: Object.entries(request.headers || {}).map(
                            ([key, value]) => ({
                              key,
                              value,
                              type: "text",
                            })
                          ),
                          body: request.body
                            ? {
                                mode: "raw",
                                raw: request.body,
                                options: {
                                  raw: {
                                    language: "json",
                                  },
                                },
                              }
                            : undefined,
                          url: {
                            raw: request.url || "",
                            protocol: urlParts.protocol,
                            host: urlParts.host,
                            path: urlParts.path,
                            query:
                              urlParts.query.length > 0
                                ? urlParts.query
                                : undefined,
                          },
                        },
                        response: [],
                      },
                    ],
                  };

                  const blob = new Blob([JSON.stringify(collection, null, 2)], {
                    type: "application/json",
                  });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = "postman-collection.json";
                  a.click();
                  URL.revokeObjectURL(url);
                }}
                variant="outline"
                className="w-full"
              >
                <Download className="h-4 w-4 mr-2" />
                Export as Postman Collection
              </Button>
            </div>

            {/* Import Section */}
            <div className="space-y-3">
              <h3 className="text-sm font-medium">Import Postman Collection</h3>
              <p className="text-xs text-gray-600 dark:text-gray-400">
                Paste your Postman collection JSON or upload a file
              </p>

              {/* File Upload */}
              <div className="space-y-2">
                <input
                  type="file"
                  accept=".json"
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (event) => {
                        try {
                          const content = event.target?.result;
                          setImportData(content);
                          setImportError("");
                        } catch (error) {
                          setImportError("Error reading file");
                        }
                      };
                      reader.readAsText(file);
                    }
                  }}
                  className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:border-0 file:text-sm file:font-semibold file:bg-gray-100 file:text-gray-700 hover:file:bg-gray-200"
                  style={{ borderRadius: "6px" }}
                />
              </div>

              {/* JSON Textarea */}
              <div className="space-y-2">
                <label className="text-xs font-medium">Or paste JSON:</label>
                <textarea
                  value={importData}
                  onChange={(e) => {
                    setImportData(e.target.value);
                    setImportError("");
                  }}
                  placeholder="Paste your Postman collection JSON here..."
                  className="w-full h-32 p-3 text-sm border rounded-md font-mono resize-none"
                />
              </div>

              {importError && (
                <p className="text-xs text-red-600">{importError}</p>
              )}

              <Button
                onClick={async () => {
                  try {
                    const collection = JSON.parse(importData);

                    // Validate basic Postman collection structure
                    if (!collection.info || !collection.item) {
                      setImportError("Invalid Postman collection format");
                      return;
                    }

                    // Create a new collection with imported name and description
                    const collectionName =
                      collection.info.name || "Imported Collection";
                    const collectionDescription =
                      collection.info.description || "Imported from Postman";

                    const newCollection = await createCollection(
                      collectionName,
                      collectionDescription,
                      "blue"
                    );

                    // Function to parse Postman request into our format
                    const parseRequest = (postmanItem) => {
                      if (!postmanItem.request) return null;

                      const request = postmanItem.request;

                      // Convert headers (V2.1 format)
                      const headers = {};
                      if (request.header && Array.isArray(request.header)) {
                        request.header.forEach((h) => {
                          if (h.key && h.value && h.type !== "disabled") {
                            headers[h.key] = h.value;
                          }
                        });
                      }

                      // Build URL from V2.1 format
                      let fullUrl = "";
                      if (typeof request.url === "string") {
                        fullUrl = request.url;
                      } else if (
                        request.url &&
                        typeof request.url === "object"
                      ) {
                        // Handle V2.1 URL object format
                        if (request.url.raw) {
                          fullUrl = request.url.raw;
                        } else {
                          // Construct URL from parts
                          const protocol = request.url.protocol || "https";
                          const host = Array.isArray(request.url.host)
                            ? request.url.host.join(".")
                            : request.url.host || "";
                          const path = Array.isArray(request.url.path)
                            ? "/" + request.url.path.join("/")
                            : request.url.path || "";

                          fullUrl = `${protocol}://${host}${path}`;

                          // Add query parameters
                          if (
                            request.url.query &&
                            Array.isArray(request.url.query)
                          ) {
                            const queryParams = request.url.query
                              .filter((q) => q.key && q.value && !q.disabled)
                              .map(
                                (q) =>
                                  `${encodeURIComponent(
                                    q.key
                                  )}=${encodeURIComponent(q.value)}`
                              )
                              .join("&");

                            if (queryParams) {
                              fullUrl += "?" + queryParams;
                            }
                          }
                        }
                      }

                      // Extract body content
                      let bodyContent = "";
                      if (request.body) {
                        if (request.body.mode === "raw" && request.body.raw) {
                          bodyContent = request.body.raw;
                        } else if (
                          request.body.mode === "formdata" &&
                          request.body.formdata
                        ) {
                          // Convert form data to JSON representation
                          const formObj = {};
                          request.body.formdata.forEach((item) => {
                            if (
                              item.key &&
                              item.value &&
                              item.type !== "file"
                            ) {
                              formObj[item.key] = item.value;
                            }
                          });
                          bodyContent = JSON.stringify(formObj, null, 2);
                        } else if (
                          request.body.mode === "urlencoded" &&
                          request.body.urlencoded
                        ) {
                          // Convert URL encoded to JSON representation
                          const urlEncodedObj = {};
                          request.body.urlencoded.forEach((item) => {
                            if (item.key && item.value) {
                              urlEncodedObj[item.key] = item.value;
                            }
                          });
                          bodyContent = JSON.stringify(urlEncodedObj, null, 2);
                        }
                      }

                      return {
                        name: postmanItem.name || "Untitled Request",
                        method: request.method || "GET",
                        url: fullUrl,
                        headers,
                        body: bodyContent,
                        description: postmanItem.description || "",
                      };
                    };

                    // Process all items in the collection (including nested folders)
                    const processItems = async (items, collectionId) => {
                      for (const item of items) {
                        if (item.item && Array.isArray(item.item)) {
                          // This is a folder, process its items recursively
                          await processItems(item.item, collectionId);
                        } else if (item.request) {
                          // This is a request, parse and add it
                          const parsedRequest = parseRequest(item);
                          if (parsedRequest) {
                            await addRequestToCollection(
                              collectionId,
                              parsedRequest
                            );
                          }
                        }
                      }
                    };

                    // Process all items in the collection
                    await processItems(collection.item, newCollection.id);

                    // Set the imported collection as active
                    setActiveCollectionId(newCollection.id);

                    setShowImportExportModal(false);
                    setImportData("");
                    setImportError("");

                    // Show success message
                    console.log(
                      `Successfully imported collection: ${collectionName} with ${collection.item.length} items`
                    );
                  } catch (error) {
                    console.error("Import error:", error);
                    setImportError(
                      "Failed to import collection: " + error.message
                    );
                  }
                }}
                disabled={!importData.trim()}
                className="w-full"
              >
                <Upload className="h-4 w-4 mr-2" />
                Import Collection
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
